- strukturovaný dotazovaný jazyk
- https://is.muni.cz/auth/el/fi/podzim2025/PB168/um/slides05-sql.pdf
## Basic Query Structure
 - **select** A1, A2, ..., An
 - **from** r1, r2, ..., rn
 - **where** C

- atribute (např.: jméno, adresa, rok...)
- relation (např.: tabulka reprezentující osoby)
- condition (např.: rok > 1970)
## The select Clause
- Relation
	- *instruktor (id, name, debt_name, salary)*
- Find the names of all instructors:
	- select name
	- from instructor

- elimination of duplicates -> select distinct ... from ...

- select clause can contain arithmetic expressions
	- +, -, \*, and /,
	- operating on constants or attributes of tuples
	- functions (nullif(), upper(), to_char(),...)
## The where Clause
- např.: where dept_name = 'Comp. Sci.' and salary > 80'000
- např.: where salary / 12 > 6000
## The from Clause
- Find the cartesian product instructor x teaches:
	- select \* from instructor, teaches
- ![[Pasted image 20251111163023.png | 500]]

## Joins
- Relations:
	- instructor (id, name, dept_name, salary)
	- course (course_id, title, dept_name)
	- section (course_id, sec_id, semestr, year)
	- teaches (id, course_id, sec_id)
- all instructors who teach courses, find names and course id of each course they teach
	- **select** name, course_id
	- **from** instructor, teaches
	- **where** instructor.id = teaches.id
- Find the course id, title, semester and year of each course offered by the “Comp. Sci.” department
	- **select** course.course_id, title, semester, year
	- **from** course, teaches, section
	- **where** course.course_id = teaches.course_id and teaches.course_id = section.course_id and teaches.sec_id = section.sec_id and dept_name = 'Comp. Sci.'
## Natural Join
- "Natural join matches tuples with the same values for all common attributes, and retains only one copy of each common column"
- For relations:
	- instructor (id, name, dept_name, salary)
	- teaches (id, course_id, sec_id, semestr, year)
- **select** * **from** instructor **natural join** teaches;
- ![[Pasted image 20251111163624.png | 500]]

### Danger in natural join
- beware of unrelated attributes with same name which get equated incorrectly

- relations:
	- instructor (id, name, dept_name, salary)
	- course (course_id, title, dept_name)
	- section (course_id, sec_id, semester, year)
	- teaches (id, course_id, sec_id)
- List the names of instructors along with the titles of courses that they teach.
	- ==Incorrect version== (equates course.dept_name with instructor.dept_name) 
		- **select** name, title
		- **from** (instructor **natural join** teaches) **natural join** course;
	- ==Correct version==
		- **select** name, title
		- **from** (instructor **natural join** teaches), course
		- **where** teaches.course_id= course.course_id
	- Another correct version
		- **select** name, title
		- **from** (instructor **natural join** teaches) **join** course **using**(course_id);
## Ordering the Display of TUples
- select name from instructor order by name
- desc / asc
	- order by name desc
## Where Clause Predicates
- **between**
- Example:
	- Find the names of all instructors with salary between $90,000 and $100,000 (that is, >= $90,000 and =< $100,000)
		- **select** name
		- **from** instructor
		- **where** salary **between** 90000 **and** 100000
- Tuple comparison
	- select name, course_id
	- from instructor, teaches
	- where (instructor.ID, dept_name) = (teaches.ID, ’Biology’);

## Null Values
- unknown value / does not exists
- The result of any arithmetic expression involving null is null
	- Example: 5 + null returns null
- The predicate is null can be used to check for null values.
	- Example: Find all instructors whose salary is null.
		- select name
		- from instructor
		- where salary ==is null==

## Duplicates
prez

## Set Operations (union, intersect, except)
- Relation:
	- teaches (id, course_id, sec_id, semester, year)
- Find courses that ran in Fall 2009 or in Spring 2010
	-  (select course_id from teaches where semester = ‘Fall’ and year = 2009) 
	- union
	- (select course_id from teaches where semester = ‘Spring’ and year = 2010)
- Find courses that ran in Fall 2009 and in Spring 2010
	- (select course_id from teaches where semester = ‘Fall’ and year = 2009) 
	- intersect
	- (select course_id from teaches where semester = ‘Spring’ and year = 2010)
- Find courses that ran in Fall 2009 but not in Spring 2010
	- (select course_id from teaches where semester = ‘Fall’ and year = 2009) 
	- except
	- (select course_id from teaches where semester = ‘Spring’ and year = 2010)

# Cvičení 4
## 2
- Příkaz SELECT jazyka SQL lze zapsat jako: SELECT A1 , …, Ak FROM r1 , …, rn WHERE podmínka
	- tento zápis převeďte do relační algebry
- Mějme relace:
	- předmět (kód, název, kredity)
	- zápis (učo, kód, ukončení)
	- student (učo, jméno, příjmení)
- V SQL uveďte dotazy, jejichž výsledkem jsou:
	- názvy předmětů, které mají alespoň tři kredity; 
		- SELECT název FROM předmět WHERE kredity >= 3
	- názvy předmětů, které si studenti zapsali na zápočet;
		- SELECT název FROM předmět, zápis WHERE zápis.ukončení='z' and předmět.kód = zápis.kód
	- předměty, jejichž kód začíná ‘PV’;
		- SELECT all FROM předmět WHERE kód LIKE 'PV%'
	- předměty, které mají v názvu slovo ‘angličtina’;
		- SELECT all FROM předmět WHERE název LIKE '%angličtina%' or nazev LIKE '%Angličtina%'
	- jména a příjmení studentů uspořádaná podle abecedy.
		- SELECT all FROM student order by prijmení, jmeno
			- defaultně ASC
## 4
- Pro relaci
	- produkt
		- ![[Pasted image 20251111171357.png | 400]]
- Vytvořte dotaz v SQL, který vrátí názvy produktů a jejich cenu včetně 20% daně.
	- SELECT nazev, cena_bez_dph * 1.21 AS end_price FROM product
- Operátor přejmenování AS: SELECT jedn_množství AS množství FROM produkt;
	- 
- Upravte příklad tak, že bude vracet dva atributy pojmenované název a cena_s_DPH.
	- Samostatně: Tento dotaz převeďte do relační algebry.
	- x
## 5
- Uvažujte relaci test (A,B,C) 
- Přejmenování relací v SQL:
		- SELECT A, B, C FROM test AS t WHERE t.A=17;
	- Zároveň lze přejmenovat i atributy:
		- SELECT nA, nB, nC FROM test AS t (nA,nB,nC) WHERE nA=17;
- Výsledkem operace SELECT je opět relace 
	- tj. SELECT lze použít v části FROM:
	
	- SELECT p.název FROM předmět AS p,
		- (SELECT kód FROM zápis WHERE ukončení=‘z’) AS z
	- WHERE p.kód=z.kód;
## 6
- Operace spojení 
- Varianty INNER JOIN, \[LEFT | RIGHT | FULL] OUTER JOIN 
	- SELECT … FROM r1 NATURAL INNER JOIN r2 
	- SELECT … FROM r1 INNER JOIN r2 ON podmínka 
	- SELECT … FROM r1 INNER JOIN r2 USING (seznam atributů) 

- Mějme relace 
	- předmět (kód, název, kredity)
	- skupina (kód, číslo, kapacita) 
- Formulujte SQL dotazy: 
- předmět ![[Pasted image 20251111172956.png]] skupina 
- pro každou seminární skupinu vypište její číslo, kapacitu a název odpovídajícího předmětu; 
	- select cislo,kapacita,nazev from skupina full outer join predmet using (kod)
- vypište dvojice kód předmětu a číslo skupiny.  ve výsledku se musí objevit kódy všech předmětů
## 7
![[Pasted image 20251111173301.png | 500]]
- select sum(kapacita) from skupina where kod='PB154'
- select kod, sum(kapacita) from skupina group by kod
- select nazev, string_agg(cislo::var_char, ','), sum(kapacita) from predmet left join skupina using kod group by kod

- select nazev, count(kapacita) from predmet left join skupina using (kod) group by kod order by count(cislo)
## 9
- Vnořený SELECT v klauzuli WHERE: 
	- Používaný s množinovými operátory 
		- IN, NOT IN, EXISTS, > ANY (), = ANY (), …. SELECT … FROM … WHERE A IN (SELECT A FROM …) 
- Mějme relace
	- předmět (kód, název, kredity)
	- zápis (učo, kód, ukončení)
	- student (učo, jméno, příjmení) 
- Formulujte SQL dotaz, který vybírá: 
	- kódy předmětů, které nemá zapsaný žádný student; 
		- select kod from predmet where kod not in (select kod from zapis)
	- předměty s následujícími kódy MA102, PB154, PV004; 
		- select \* from predmet where kod in ('MA102', 'PB154', 'PV004')
	- názvy předmětů s nejvíce kredity; 
		- select nazev from predmet where kredity=(select max(kredity) from predmet)
	- jména studentů, kteří mají zapsané alespoň dva předměty.
		- 

# Pokračování
## Aggregate fce
- avg, min, max, sum, count
- Relations:
	- instructor (id, name, dept_name, salary)
	- teaches (id, course_id, sec_id, semestr, year)
- Find the average salary of instructors in the Computer Science department
	- select avg (salary)
	- from instructor 
	- where dept_name= ’Comp. Sci.’;
	- ![[Pasted image 20251111180541.png | 500]]
- Find the total number of instructors who teach a course in the Spring 2010 semester
	- select count (distinct id) 
	- from teaches 
	- where semester = ’Spring’ and year = 2010
- Find the average salary of instructors in each department
	- select dept_name, avg (salary)
	- from instructor
	- group by dept_name;
- ![[Pasted image 20251111180701.png | 400]]

- Attributes in select clause outside of aggregate functions must appear in group by list
	- Erroneous query:
		- select dept_name, id, avg (salary)
		- from instructor
		- group by dept_name;
### Aggregate fce - Having Clause
- Relations: 
	- instructor (id, name, dept_name, salary)
- Find the names and average salaries of all departments whose average salary is greater than 42,000
	- select dept_name, avg (salary)
	- from instructor
	- group by dept_name
	- having avg (salary) > 42000;
- nebo
	- select \* from (select dept_name, avg (salary) as a
	- from instructor
	- group by dept_name)
	- where a > 42000;

## Null Values and Aggregates
- Total all salaries:
	- select sum (salary ) from instructor
- Above statement ignores null amounts
- Result is null if there is no non-null amount

- All aggregate operations except count(\*) ignore tuples with null values on the aggregated attributes
- What if collection has only null values?
	- count returns 0
	- all other aggregates return null

dpolnit str ~40 až 75
