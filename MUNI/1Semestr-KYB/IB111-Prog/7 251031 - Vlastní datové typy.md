# Vlastn√≠ datov√© typy
## Motivace
- Udr≈æov√°n√≠ dat pohromadƒõ
	- P≈ô√≠klad ‚Äì chceme uchov√°vat z√°znamy o knih√°ch:
		- n√°zev knihy, autor, ISBN apod.
- **Jak reprezentovat?**
	- `Ntice` (tuples):
		- nepojmenovan√© slo≈æky, nemƒõnn√© (a≈æ na hodnoty jejich slo≈æek v podobƒõ mƒõniteln√Ωch objekt≈Ø jako nap≈ô. seznamy).
	- `Seznamy`:
		- mƒõniteln√©, nepojmenovan√© (je n√°zev prvn√≠ nebo autor prvn√≠?),
		- nevhodn√© pro polo≈æky r≈Øzn√Ωch typ≈Ø (jak otypovat?).
	- `Slovn√≠ky`:
		- mƒõniteln√©, pojmenovan√©, nevhodn√© pro polo≈æky r≈Øzn√Ωch typ≈Ø,
		- nelze spol√©hat na to, ≈æe je zachov√°na urƒçit√° struktura a p≈ôipravit si operace spol√©haj√≠c√≠ na tuto strukturu.

- Schov√°v√°n√≠ ≈°kared√Ωch detail≈Ø
	- P≈ô√≠klad ‚Äì vzpome≈àte si na **dvojrozmƒõrn√© matice**:
		- reprezentov√°ny pomoc√≠ seznamu seznam≈Ø,
		- nepƒõkn√Ω zp≈Øsob zji≈°≈•ov√°n√≠ velikosti matice,
		- problematick√© udr≈æov√°n√≠ konzistence.
- Co bychom chtƒõli?
	- Spolu s matic√≠ si udr≈æovat informace o jej√≠ velikosti.
	- M√≠t **nƒõco, co kontroluje p≈ô√≠stupy do matice**.

- Vlastn√≠ datov√© struktury
	- Co kdybychom chtƒõli m√≠t nƒõjakou vlastn√≠ datovou strukturu?
	- Nap≈ô. z≈ôetƒõzen√Ω seznam, nƒõjak√Ω druh stromov√© struktury, ‚Ä¶
- Vlastn√≠ specializovan√© operace ‚Äì metody
	- U≈æ jsme vidƒõli u seznam≈Ø, slovn√≠k≈Ø apod.
```python
s = [7, 14, 42, 0]
s.append(9)

d = {"a": 1, "b": 2}
c = d.get("c")
```

## Odboƒçka: Souƒçinov√© a souƒçtov√© typy
- Souƒçinov√© typy ùê¥ √ó ùêµ
	- Hodnota m√° 2 slo≈æky: jedna je typu ùê¥, druh√° typu ùêµ.
	- Podobnƒõ pro souƒçin v√≠ce typ≈Ø.
	- V Pythonu: ntice, jednoduch√© t≈ô√≠dy (uvid√≠me za chv√≠li).
	- Jin√© jazyky: ntice, z√°znamy (record, struct), v Haskellu typov√© konstruktory s v√≠ce parametry.
	- Reprezentuje **kart√©zsk√Ω souƒçin mno≈æin hodnot**.

- Souƒçtov√© typy ùê¥ + ùêµ
	- Hodnota je buƒè typu ùê¥ nebo typu ùêµ.
		- Podobnƒõ pro souƒçet v√≠ce typ≈Ø.
	- V Pythonu: typov√© anotace s | (dal≈°√≠ slajd).
	- Jin√© jazyky: (tagged) union, variant, v Haskellu datov√© typy s v√≠ce typov√Ωmi konstruktory.
	- **(Disjunktn√≠) sjednocen√≠**.

## Typov√° anotace ‚Äì sjednocen√≠ typ≈Ø
- `X | Y`
	- Buƒè hodnota typu `X` nebo typu `Y`.
	- Klasick√© sjednocen√≠, ne disjunktn√≠ (rozd√≠l proti jin√Ωm jazyk≈Øm).
	- Mo≈æno i v√≠ce typ≈Ø: `X | Y | Z` apod.
- **Zji≈°tƒõn√≠ skuteƒçn√©ho typu**
	- Predik√°t `isinstance(v√Ωraz, typ)`.
- **Pou≈æit√≠ s ‚Äòmypy‚Äò**
	- Podobnƒõ jako u `X | None`, mypy um√≠ odvodit typ hodnoty uvnit≈ô vƒõtv√≠ p≈ô√≠kazu `if` a za p≈ô√≠kazem `assert -`
		- p≈ôi pou≈æit√≠ `isinstance`.

## Vlastn√≠ souƒçinov√© typy
- **Z√°znamy, struktury**
	- Datov√Ω typ slo≈æen√Ω z v√≠ce pojmenovan√Ωch polo≈æek.
	- Typicky fixn√≠ poƒçet.
	- Deklarovan√© typy ‚Äì mohou se u r≈Øzn√Ωch polo≈æek li≈°it.
	- C: `struct`.
	- Pascal: `record`.
- ==**T≈ô√≠dy**==
	- Roz≈°√≠≈ôen√≠ struktur.
	- Kombinuj√≠ data a funkce (metody).
	- C++, Java, Python, ‚Ä¶: `class`.
	- Mnohem komplikovanƒõj≈°√≠, ne≈æ si uk√°≈æeme:
		- dƒõdiƒçnost, virtu√°ln√≠ vol√°n√≠ (realizace polymorfismu), ‚Ä¶

# Vlastn√≠ datov√© typy v Pythonu
### Varov√°n√≠
- Pozor!
	- Toto nen√≠ objektovƒõ orientovan√© programov√°n√≠ (OOP).
	- OOP je podstatnƒõ slo≈æitƒõj≈°√≠.
	- Zde pou≈æ√≠v√°me t≈ô√≠dy jen velmi jednoduch√Ωm zp≈Øsobem,
		- n√°hrada za z√°znamy (struktury).

## Vlastn√≠ datov√© typy v Pythonu
- **Objekty** vlastn√≠ch datov√Ωch typ≈Ø (t≈ô√≠d) se skl√°daj√≠ z atribut≈Ø.
	- Nƒõco jako polo≈æky ntice, ale
		- ==jsou pojmenovan√©==,
		- ==d√° se do nich p≈ôi≈ôadit== ‚Äì vnit≈ôn√≠ p≈ôi≈ôazen√≠.
	- Chovaj√≠ se podobnƒõ jako promƒõnn√©, resp. polo≈æky seznam≈Ø.
	- P≈ô√≠stup k atributu pomoc√≠ teƒçky: `v√Ωraz.jm√©no_atributu`,
		- v√Ωraz se mus√≠ vyhodnotit na objekt spr√°vn√©ho typu (typicky promƒõnn√°).

### T≈ô√≠dy ‚Äì definice nov√©ho typu.
```python
class Jm√©noTypu:
	"""Dokumentace t≈ô√≠dy."""

	def __init__(self, form√°ln√≠ parametry, ‚Ä¶) -> None:
		# inicializace

	# definice metod
	def metoda(self, form√°ln√≠ parametry, ‚Ä¶) -> typ:
		# tƒõlo metody
```

- Inicializaƒçn√≠ funkce `__init__`
	- Povinn√Ω form√°ln√≠ parametr `self`, p≈ô√≠p. dal≈°√≠ form. parametry.
		- `self` odkazuje na pr√°vƒõ vznikaj√≠c√≠ objekt.
	- C√≠lem inicializace je vytvo≈ôit atributy (pomoc√≠ p≈ôi≈ôazen√≠).
- Vytvo≈ôen√≠ objektu vlastn√≠ho typu
	- Jm√©no t≈ô√≠dy se vol√° jako funkce.
	- Skuteƒçn√© parametry vol√°n√≠ se sv√°≈æ√≠ s dal≈°√≠mi form√°ln√≠mi parametry `__init__`.
```python
class Person:
	def __init__(self, name: str, age: int):
		self.name = name
		self.age = age


homer = Person("Homer Simpson", 34)
```

### Metody
- Definice metody
	- Funkce definovan√° uvnit≈ô t≈ô√≠dy.
	- Povinn√Ω form√°ln√≠ parametr `self`, p≈ô√≠p. dal≈°√≠ form. parametry.
		- `self` odkazuje na aktu√°ln√≠ objekt.
- Vol√°n√≠ metody
	- v√Ωraz.jm√©no_metody(dal≈°√≠ skuteƒçn√© parametry, ‚Ä¶).
	- v√Ωraz se vyhodnot√≠ na objekt,
		- typ objektu urƒç√≠, ve kter√© t≈ô√≠dƒõ se hled√° jm√©no_metody,
		- objekt se p≈ôed√° v parametru `self`.
```python
class Person:
	def say_hello(self) -> None:
		print(self.name, "says hello.")

homer.say_hello()
```

- ƒåist√° metoda
	- Metoda, kter√° je z√°rove≈à ƒçistou funkc√≠.
	- Nem√° vedlej≈°√≠ efekty:
		- zejm√©na ani nemodifikuje aktu√°ln√≠ objekt.
	- P≈ôi r≈Øzn√Ωch vol√°n√≠ch se stejn√Ωmi skuteƒçn√Ωmi parametry vrac√≠ stejn√© hodnoty,
		- se stejn√Ωm aktu√°ln√≠m objektem ve stejn√©m stavu.
- Metoda-predik√°t
	- Metoda, kter√° je z√°rove≈à predik√°tem.
	- ƒåist√° metoda vracej√≠c√≠ bool.

### T≈ô√≠dy a typov√© anotace
- Jm√©no t≈ô√≠dy je typ.
	- D√° se pou≈æ√≠t jako typov√° anotace
		- za definic√≠ t≈ô√≠dy,
		- v tƒõle inicializaƒçn√≠ funkce a metod t≈ô√≠dy.
	- V hlaviƒçk√°ch metod nebo p≈ôed definic√≠ t≈ô√≠dy mus√≠me pou≈æ√≠t tzv. dop≈ôednou referenci na typ:
		- jm√©no typu jako ≈ôetƒõzec,
		- p≈ôi pou≈æit√≠ | mus√≠ b√Ωt jako ≈ôetƒõzec cel√© sjednocen√≠.
- **Typov√© anotace parametr≈Ø a n√°vratov√Ωch hodnot**
	- `self` nemus√≠ m√≠t typovou anotaci.
	- `__init__` nemus√≠ m√≠t typovou anotaci n√°vratov√© hodnoty,
		- ale je pak t≈ôeba m√≠t alespo≈à jeden anotovan√Ω parametr.
## P≈ô√≠klady vlastn√≠ch datov√Ωch typ≈Ø
- Knihovna
	- Chceme si pamatovat seznam knih.
	- Kniha m√°:
		- n√°zev,
		- autora,
		- ISBN.
	- Naƒç√≠t√°n√≠/ukl√°d√°n√≠ dat z/do soubor≈Ø ‚Äì pozdƒõj≈°√≠ p≈ôedn√°≈°ka.

```python
class Book:
	def __init__(self, author: str, title: str, isbn: str):
		self.author = author
		self.title = title
		self.isbn = isbn

# this is how we create books:
dune = Book("Frank Herbert", "Dune", "978-0441172719")
temno = Book("Bohuslav Balcar & Petr ≈†tƒõp√°nek", "Teorie mno≈æin", "80-200-0470-X")
```


- Datab√°ze student≈Ø a p≈ôedmƒõt≈Ø
	- Chceme jednoduchou datab√°zi p≈ôedmƒõt≈Ø a student≈Ø.
	- Student m√°:
		- UƒåO a
		- jm√©no.
	- P≈ôedmƒõt m√°:
		- k√≥d a
		- seznam student≈Ø.

```python
class Student:
	def __init__(self, uco: int, name: str):
		self.uco = uco
		self.name = name
class Course:
	def __init__(self, code: str):
		self.code = code
		self.students: list[Student] = []
```
```python
class Course:
	# ...
	def add_student(self, student: Student) -> None:
		self.students.append(student)

	def get_student_names(self) -> list[str]: names = []
		for student in self.students:
			names.append(student.name)
		return names
```
```python
jimmy = Student(555007, "James Bond")

ib111 = Course("IB111")

ib111.add_student(Student(555000, "Jan Nov√°k"))
ib111.add_student(jimmy)
ib111.add_student(Student(999999, "Kry≈°tof Harant"))
```


- Matice
	- Chceme uchov√°vat i jejich velikost.
	- Chceme bezpeƒçn√Ω p≈ô√≠stup k prvk≈Øm.
```python
class Matrix:
	def __init__(self, rows: int, cols: int):
		self.rows = rows
		self.cols = cols
		self.matrix = [[0 for j in range(self.cols)]
			for i in range(self.rows)]
```
```python
class Matrix:
	# ...
	def check(self, row: int, col: int) -> None:
		assert 0 <= row < self.rows
		assert 0 <= col < self.cols
	def get(self, row: int, col: int) -> int:
		self.check(row, col)
		return self.matrix[row][col]
	def set(self, row: int, col: int, value: int) -> None:
		self.check(row, col)
		self.matrix[row][col] = value
```

```python
def matrix_mult(left: Matrix, right: Matrix) -> Matrix:
	assert left.cols == right.rows, \
	"Incompatible matrices."
	result = Matrix(left.rows, right.cols)
	for i in range(left.rows):
		for j in range(right.cols):
			for k in range(left.cols):
				result.set(i, j, result.get(i, j) + left.get(i, k) * 
					right.get(k, j))
	return result
```

## Vlastn√≠ datov√° struktura
### Jednosmƒõrnƒõ z≈ôetƒõzen√Ω seznam
- ![[Pasted image 20251031105913.png | 500]]
```python
class Node:
def __init__(self, data: str):
self.data = data
self.next: Node | None = None
```
```python
class LinkedList:
	def __init__(self) -> None:
		self.first: Node | None = None
	def add_to_beginning(self, data: str) -> None:
		node = Node(data)
		node.next = self.first
		self.first = node
	def delete_first(self) -> None:
		if self.first is not None:
			self.first = self.first.next
```
```python
class LinkedList:
	# ...
	def to_list(self) -> list[str]:
		result = []
		node = self.first
		while node is not None:
			result.append(node.data)
			node = node.next
		return result


my_ll = LinkedList()
my_ll.add_to_beginning("Hello")
my_ll.add_to_beginning("Ahoj")
elems1 = my_ll.to_list()
my_ll.delete_first()
elems2 = my_ll.to_list()
```

### Vlastn√≠ datov√° struktura: z√°sobn√≠k
- V≈°imnƒõte si
	- Pomoc√≠ z≈ôetƒõzen√©ho seznamu m≈Ø≈æeme implementovat z√°sobn√≠k.
	- Vlastnƒõ u≈æ ho skoro m√°me ve t≈ô√≠dƒõ LinkedList:
		- `push`: add_to_beginning.
		- `pop`: delete_first a≈æ na to, ≈æe nevrac√≠ hodnotu.
		- `top`, `empty`: snadno doplniteln√©.
- **Z√°sobn√≠k** (≈ôetƒõzc≈Ø) pomoc√≠ z≈ôetƒõzen√©ho seznamu.
```python
class Stack:
	def __init__(self) -> None:
		self.top: Node | None = None

	def push(self, data: str) -> None:
		node = Node(data)
		node.next = self.top
		self.top = node

	def pop(self) -> str:
		assert self.top is not None
		result = self.top.data
		self.top = self.top.next
		return result
```

### Vlastn√≠ datov√° struktura: fronta
- Datov√Ω typ fronta
	- Prvky v po≈ôad√≠ FIFO: First In First Out.
	- Operace:
		- vlo≈æen√≠ (enqueue, nƒõkdy t√©≈æ push),
		- odebr√°n√≠ (dequeue, pull ƒçi pop),
		- n√°hled na prvn√≠ prvek,
		- test pr√°zdnosti.

- Seznam s vkl√°d√°n√≠m na konec
	- push: `q.append(‚Ä¶)`,
	- pull: `q.pop(0)` ‚Äì
	- line√°rn√≠ slo≈æitost (v≈Øƒçi d√©lce fronty).
- Seznam s vkl√°d√°n√≠m na zaƒç√°tek
	- pull: `q.pop()`,
	- push: `q.insert(0, ‚Ä¶)` ‚Äì
		- line√°rn√≠ slo≈æitost (v≈Øƒçi d√©lce fronty).
- Jin√© mo≈ænosti?
	- Ide√°lnƒõ ***s konstantn√≠m vkl√°d√°n√≠m i odeb√≠r√°n√≠m prvk≈Ø z fronty***.

- Obousmƒõrnƒõ z≈ôetƒõzen√Ω seznam
	- Ano, snadn√© p≈ôid√°v√°n√≠/odeb√≠r√°n√≠ na obou konc√≠ch, ale zbyteƒçnƒõ komplikovan√©.
- Jednosmƒõrnƒõ z≈ôetƒõzen√Ω seznam
	- Um√≠me p≈ôid√°vat a odeb√≠rat prvky na zaƒç√°tku.
	- Um√≠me p≈ôid√°vat prvky na konec ‚Äì
		- kdy≈æ si budeme pamatovat odkaz na posledn√≠ prvek.
- ![[Pasted image 20251031110855.png | 550]]

- implementace fronty:
```python
class Queue:
	def __init__(self) -> None:
		self.first: Node | None = None
		self.last: Node | None = None

	def push(self, data: str) -> None:
		node = Node(data)
		if self.last is None:
			self.first = node
		else:
			self.last.next = node
		self.last = node
```
- Odebr√°n√≠ prvku z fronty
	- Je toto ≈ôe≈°en√≠ korektn√≠? NE!
```python
class Queue:
	# ...
	def pull(self) -> str:
		assert self.first is not None
		result = self.first.data
		self.first = self.first.next
		return result
```
#### Odboƒçka: Invariant
- **Invariant**
	- V matematice: vlastnost struktury, kter√° se nemƒõn√≠ jej√≠mi transformacemi.
- Invariant datov√© struktury
	- Vlastnost datov√© struktury, kter√° se nemƒõn√≠ vol√°n√≠mi metod,
		- tj. logick√° podm√≠nka, kter√° plat√≠ v≈ædy mezi vol√°n√≠mi metod.
		- (Nemus√≠ platit uvnit≈ô metod.)
	- Souƒç√°st vstupn√≠ i v√Ωstupn√≠ podm√≠nky ka≈æd√© metody.
	- Souƒç√°st v√Ωstupn√≠ podm√≠nky inicializaƒçn√≠ funkce `__init__`.
- Jin√© druhy invariant≈Ø (v pozdƒõj≈°√≠ch p≈ôedmƒõtech)
	- **Invariant funkce**: souƒç√°st vstupn√≠ i v√Ωstupn√≠ podm√≠nky funkce.
	- **Invariant cyklu**: plat√≠ p≈ôi ka≈æd√©m p≈ô√≠chodu na hlaviƒçku cyklu.

```python
class Queue:
	def __init__(self) -> None:
		self.first: Node | None = None
		self.last: Node | None = None
```
- **Jak√Ω invariant** m√° (mj.) m√≠t n√°≈° typ Queue?
	- ‚Äû*first je `None` **pr√°vƒõ tehdy, kdy≈æ** last je `None`.*‚Äú
- **Je to skuteƒçnƒõ invariant?**
	- `__init__`: OK, po skonƒçen√≠ je podm√≠nka splnƒõna.
	- `push`: OK, kdy≈æ plat√≠ podm√≠nka na zaƒç√°tku, plat√≠ i na konci.
	- `pull`: ==NE!==
		- M√°-li fronta jen jeden uzel, skonƒç√≠me v situaci, kdy **first je None**, ale last se odkazuje na p≈Øvodn√≠ uzel.

- ==Implementace fronty: znovu a l√©pe==
```python
def pull(self) -> str:
	assert self.first is not None
	result = self.first.data
	self.first = self.first.next
	if self.first is None:
		self.last = None
	return result
```

## Statick√© atributy
- ==Definov√°ny p≈ô√≠mo ve t≈ô√≠dƒõ.==
- Pat≈ô√≠ samotn√© t≈ô√≠dƒõ, ne objekt≈Øm.
- V tomto p≈ôedmƒõtu nepou≈æ√≠v√°me.
```python
class MyClass:
	x = 0
	def __init__(self, n):
		self.y = n


print(MyClass.x) # 0
my_object = MyClass(17)
print(my_object.y) # 17
print(my_object.x) # 0 (fskuteƒçnosti MyClass.x)
```

### Statick√© atributy: na co si d√°t pozor
- V ƒçem je probl√©m?
```python
class Student:
	hobbies: list[str] = []
	def __init__(self, name: str):
		self.name = name
	def add_hobby(self, hobby: str) -> None:
		self.hobbies.append(hobby)

mirek = Student("Mirek Du≈°√≠n")
mirek.add_hobby("pom√°h√°n√≠ slab≈°√≠m")
mirek.add_hobby("svƒõtov√Ω m√≠r")

bidlo = Student("Dlouh√© Bidlo")
bidlo.add_hobby("alkohol")

print(mirek.hobbies)
```

## Teƒçkov√° notace
Jak√Ω je (mj.) rozd√≠l mezi bƒõ≈ænou funkc√≠ a metodou objektu?
- V Pythonu nelze m√≠t dvƒõ funkce, kter√© se jmenuj√≠ stejnƒõ,
- ale r≈Øzn√© objekty mohou m√≠t stejnƒõ pojmenovan√© metody.
```python
class Dog:
	def make_sound(self) -> None:
		print("Whoof!")
class SmallFurryAnimalFromAlphaCentauri:
	def make_sound(self) -> None:
		print("Qwxrq!")

fido = Dog()
fido.make_sound()
frrq = SmallFurryAnimalFromAlphaCentauri()
frrq.make_sound()
```
