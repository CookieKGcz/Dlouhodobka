## Heap 0
po spuštění
![[Pasted image 20241031165519.png]]
source code (co nás zajíma)
![[Pasted image 20241031165549.png]]
pravděpodobně se bude jednat o overflow (hráním si se sizem)
![[Pasted image 20241031165630.png]]
strcmp => rovnocenné = 0
jiný = 1
safe var je to na adrese 0x6...d0, kde je zapsáno "bico"
![[Pasted image 20241031165811.png]]
tady máme co se nám na allocovalo (máme z dřívějška 5)
![[Pasted image 20241031165901.png]]
a budeme asi muset pře bufferovat input_data
(také můžeme porovnat hodnoty adres ...b0 a ....d0 (208-176) což je 32, takže stačí napsat 33+ znaků)
vyzkoušíme
![[Pasted image 20241031170010.png]]
a máme flagu.

## Format string 0
![[Pasted image 20241031171303.png]]
tento krát v kódu je strcmp s \==, takže vyzkoušíme jak se to bude chovat bez bufferu :/

![[Pasted image 20241031171433.png]]
pravděpodobně %s nám rovnou udělalo overflow za nás?

první `Gr%114d_Cheese` vsune do kódu `%114d` (int 114 bitů? dlouhý)

druhý `Cla%sic_Che%s%steak` vsune %s, což zapříčiní chybu a vyvolá se ![[Pasted image 20241122092806.png]] 

pochopení format stringu
`printf ()`
` %[flags][width][.precision][size]type`
### specifiers (types)

	**c	Character	When used with printf functions, specifies a single-byte character; when used with wprintf functions, specifies a wide character.
	**C	Character	When used with printf functions, specifies a wide character; when used with wprintf functions, specifies a single-byte character.
	**d	Integer	Signed decimal integer.
	**i	Integer	Signed decimal integer.
	**o	Integer	Unsigned octal integer.
	**u	Integer	Unsigned decimal integer.
	**x	Integer	Unsigned hexadecimal integer; uses "abcdef".
	**X	Integer	Unsigned hexadecimal integer; uses "ABCDEF".
	**e	Floating-point	Signed value that has the form [-]d.dddde[+|-]dd[d], where d is one decimal digit, dddd is one or more decimal digits depending on the specified precision, or six by default, and dd[d] is two or three decimal digits depending on the output format and size of the exponent.
	**E	Floating-point	Identical to the e format except that E rather than e introduces the exponent.
	**f	Floating-point	Signed value that has the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision, or six by default.
	**F	Floating-point	Identical to the f format except that infinity and NaN output is capitalized.
	**g	Floating-point	Signed values are displayed in f or e format, whichever is more compact for the given value and precision. The e format is used only when the exponent of the value is less than -4 or greater than or equal to the precision argument. Trailing zeros are truncated, and the decimal point appears only if one or more digits follow it.
	**G	Floating-point	Identical to the g format, except that E, rather than e, introduces the exponent (where appropriate).
	**a	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0xh.hhhhp[+|-]dd, where h.hhhh are the hex digits (using lower case letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
	**A	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0Xh.hhhhP[+|-]dd, where h.hhhh are the hex digits (using capital letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
	**n	Pointer to integer	Number of characters that are successfully written so far to the stream or buffer. This value is stored in the integer whose address is given as the argument. The size of the integer pointed at can be controlled by an argument size specification prefix. The n specifier is disabled by default; for information see the important security note.
	**p	Pointer type	Display the argument as an address in hexadecimal digits.
	**s	String	When used with printf functions, specifies a single-byte or multi-byte character string; when used with wprintf functions, specifies a wide-character string. Characters are displayed up to the first null character or until the precision value is reached.
	**S	String	When used with printf functions, specifies a wide-character string; when used with wprintf functions, specifies a single-byte or multi-byte character string. Characters are displayed up to the first null character or until the precision value is reached.

![[Pasted image 20241122091247.png]]
## Heap 1
z heap 0 změněno jen toto
![[Pasted image 20241031182143.png]]
musíme tedy přebufferovat na pico

z minula se dá vypočítat že bufferovat se začalo po 32 znacích
takže postup je jednoduchý
![[Pasted image 20241031182315.png]]

## Heap 2
hlavní věc - pointer
![[Pasted image 20241031184910.png]]
![[Pasted image 20241108201144.png]]
![[Pasted image 20241108201206.png]]

\+ hint  ![[Pasted image 20241108200527.png]]
musíme nějak odkázat na funkci win()

pravděpodobně přes adresu funkce win

## Format String 1
![[Pasted image 20241122092911.png]]

https://lettieri.iet.unipi.it/hacking/format-strings.pdf

The simplest way to exploit a format string vulnerability is to leak information from the stack of the process under attack. **On 32b systems, a sequence of %x specifiers will cause printf() to print successive lines from the stack. On 64b systems, the first 5 %lx will print the contents of the rsi, rdx, rcx, r8, and r9, and any additional %lx will start printing successive stack lines. By studying the binary, or simply by observing the output, the attacker may be able to determine which of these lines contains the stack canary. On 32b systems the canary can be read with %x, but on 64b you need %lx, because %x will only read 4 bytes in both systems.** The only real difficulty for the attacker comes from space limitations in the controlled buffer, since the argument pointer is only moved forward by a format specifier. Any format specifier will move the argument pointer by at least one stack line (which is 4 bytes in 32b systems and 8 bytes in 64b systems), since arguments are always aligned to stack lines. Assume that the buffer size is s: the attacker can only move the argument pointer by ⌊s/2⌋ lines, which may not be enough to reach the canary’s position.

![[Pasted image 20241122100024.png]]
402118,0,7daeeaee6a00,0,1c22880,a347834,7ffdf3f817f0,7daeeacd7e60,7daeeaefc4d0,1,7ffdf3f818c0,0,0,7b4654436f636970,355f31346d316e34,3478345f33317937,35625f673431665f,7d663839623764,7,7daeeaefe8d8,2300000007,206e693374307250,a336c797453,9,7daeeaf0fde9,7daeeace0098,7daeeaefc4d0,0,7ffdf3f818d0,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25


![[Pasted image 20241122100324.png]]

ale obráceně protože little endian

rozkouzkujeme podle 8 kousků
{FTCocip
5_14m1n4
4x4_31y7
5b_g41f_
}f89b7d

a obrátíme

picoCTF{
4n1m41_5
7y13_4x4
\_f14g_b5
d7b98f}


`picoCTF{4n1m41_57y13_4x4_f14g_b5d7b98f}`

## Format String 2
![[Pasted image 20241122101052.png]]

